# В этой задаче нужно юзать динамическое программирование  

# Нужно найти базовый случай
# Когда поднимаемся на 1 ступеньку, нам нужна 1 ступенька
# когда поднимаемся на 2 ступеньки, нам нужны 2 ступеньки, которые 1+1 или 2
# когда поднимаемся по 3 ступенькам, нам нужны 3 ступени, которые 1+1+1, 1+2, 2+1
# когда поднимаемся по 4 ступенькам, нам нужно 5 ступеней, которые 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2…. Базовый случай будет:
# dp[1]=1,
# dp[2]=2,
# dp[3]=3,
# dp[4]=5

# Нахожу закономерность
# Например, чтобы добраться до текущей лестницы (ступенька 4), мы можем легко добавить 1 ступеньку от последней ступеньки (ступенька 3), и это даст нам 1+1+1+1, 1+2+1, 2+1+1. Или мы можем легко добавить 2 ступени от предпоследней (ступенька 2), и это даст нам 1+1+2 и 2+2. Так как каждый раз мы можем двигаться только на 1 или 2 шага. Нам не нужно больше предыдущей лестницы. Таким образом, мы получаем ответ 5 в сумме.

# Расширенный вариант
# Если мы можем каждый раз двигаться на 1, 2 и 3 шага. нам нужно только сложить общее количество путей последних 3 лестниц вместе.

class Solution:
    def climbStairs(self, n: int) -> int:
        # Условие ввиду того что для двух ступенек есть два один или два шага
        if n<=2: return n
        # Если ступень равна 0, нам понадобится 1 ступень, чтобы достичь ее
        dp = [0]*(n+1)
        # Сколько нужно шагов для ступенек
        dp[1] = 1
        dp[2] = 2
        # Цикл для итераций ступенек
        for i in range(3,n+1):
            dp[i] = dp[i-1]+dp[i-2]
        return dp[n]